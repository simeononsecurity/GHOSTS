{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"The GHOSTS NPC Framework","text":"<p>Developed by Carnegie Mellon University's Software Engineering Institute (SEI), The GHOSTS Framework is an open-source (OSS) software framework that enables creating, deploying, and orchestrating complex non-player character (NPC) activity within training, exercise, simulation, and educational environments. Within GHOSTS there are several systems and applications, all of which are modular and extendable to fit a wide array of use cases and needs.</p> <p>If you've never seen GHOSTS in action, watch this quick three-minute introductory video on YouTube:</p>"},{"location":"#documentation","title":"Documentation","text":"<p>This is the GHOSTS documentation site for the framework and all of its components. Each major component's detail is accessible from the main navigation. If anything is unclear or you still have questions, please do not hesitate to start a discussion \u2014 our community is growing and eager to help!</p>"},{"location":"#cyber-ranges-and-crucible","title":"Cyber Ranges and Crucible","text":"<p>GHOSTS is typically run on machines within a virtualized network, often referred to as \"the range\". This network can be as simple or as complex as required for training and exercise purposes.</p> <p>CERT's Cyber Workforce Development (CWD) team has a great deal of experience in building cyber ranges for training and exercise, captured in our technical report Foundation of Cyber Ranges. The report details the design considerations and execution plan for building high-fidelity, realistic virtual cyber ranges that deliver maximum training and exercise value for cyberwarfare participants.</p> Run GHOSTS on the Crucible Framework <p> GHOSTS runs very well within the SEI's Crucible Framework (Source Code and Docs) - which we use extensively for training and exercise here at Carnegie Mellon University (CMU)'s Software Engineering Institute, and particularly, within CERT.</p> <p>Building a sufficiently complex range for training and exercise purposes is often challenging. Crucible is a modular framework for creating, deploying, and managing virtual environments to support training, education, and exercises. Crucible is designed to be easy to use, extensible, and customizable to meet the needs of a wide variety of use cases.</p>"},{"location":"#philosophy","title":"Philosophy","text":"<p>GHOSTS evolved in our quest to create more realistic NPCs within cyberwarfare training and exercise. In 2018, we outlined our thoughts in a technical report entitled GHOSTS in the Machine: A Framework for Cyber-Warfare Exercise NPC Simulation.1 In that report, we outline how the GHOSTS framework accomplishes the creation of simulations in which NPCs realistically represent a vast array of possible encounters and outcomes. We have continued to follow our initial path since. The litmus has always been that if we looked over someone's shoulder while they were using a computer, that is what GHOSTS should look like.2</p> <p>Since then the framework has expanded to include tools that serve content in simulated environments, create NPCs with details about them that we can programmatically use to drive their decision-making, and machine learning agent preference engines. If it is related to replicating human behavior within a cyber training or exercise scenario, we are interested in how GHOSTS can contribute within that space.</p>"},{"location":"#reporting-bugs","title":"Reporting Bugs","text":"<p>Found a bug? Please report all bugs - including bugs for the individual components - in the cmu-sei/ghosts issue tracker. Include as much detail as possible including steps to reproduce, the specific components involved, and any error messages you may have found.</p>"},{"location":"#requesting-features","title":"Requesting Features","text":"<p>Have a good idea for a new feature? Submit all new feature requests through the cmu-sei/ghosts issue tracker. Include the reasons why you're requesting the new feature and how it might benefit other users.</p>"},{"location":"#license","title":"License","text":"<p>[DISTRIBUTION STATEMENT A] This material has been approved for public release and unlimited distribution.</p> <p>Copyright 2018 Carnegie Mellon University. See the LICENSE.md file for details.</p> <ol> <li> <p>This paper is influenced by our previous paper R-EACTR: A Framework for Designing Realistic Cyber Warfare Exercises which outlines a design framework for cyber warfare exercises. It ensures that designs of team-based exercises factor realism into all aspects of the participant experience. Both of these papers are natural extensions to The CERT Approach to Cybersecurity Workforce Development.\u00a0\u21a9</p> </li> <li> <p>There is also a GHOSTS video presentation from FloCon 2021 that provides a general introduction to the framework.\u00a0\u21a9</p> </li> </ol>"},{"location":"new/","title":"What's New","text":"<p>Welcome to what's new in the GHOSTS framework. Use this page to review the latest changes.</p>"},{"location":"new/#ghosts-core-v70","title":"GHOSTS Core v7.0","text":"<ul> <li>10+ significant features built by 6+ contributors!</li> <li>We surpassed 175 issues/discussions!</li> <li>These new docs are hosted on GitHub Pages</li> <li>GHOSTS PANDORA - a new tool for delivering randomized content within a range</li> <li>GHOSTS PANDORA SOCIAL - a new tool for managing social media content within a range</li> </ul> <p>In the Core Client, v7 Improves:</p> <ul> <li>Performance</li> <li>The Clean up of created artifacts</li> <li>Logging</li> <li>Cron-like scheduling (in development for all handlers)</li> <li>New handlers for Firefox and Chrome Browsers</li> <li>Complete forms</li> <li>Post payloads (images, files, etc.)</li> <li>Better UA string handling</li> <li>SharePoint</li> <li>Drupal Blog Management</li> <li>Jabber (XMPP)</li> <li>RDP</li> <li>sFTP</li> <li>SSH</li> <li>Client Now Supports AutoIT</li> </ul>"},{"location":"quickstart/","title":"Quick Start","text":"No Compilers Necessary <p>This section details the installation and configuration of GHOSTS from precompiled binaries for both the server and the client.</p> <p>If you are just checking out the project for the first time and want to see NPCs performing activities, skip to the client section below. Otherwise, it is easier to install the API first and then a client that will connect to that installed API instance.</p>"},{"location":"quickstart/#ghosts-api-server","title":"GHOSTS API Server","text":"<p>Easy installation requires:</p> <ol> <li>Install \ud83d\udc33 Docker</li> <li>Install Docker Compose</li> <li> <p>We'll use this docker-compose.yml file in the following command block which will download the required containers will automatically. The commands to stand up the GHOSTS API containers is:</p> <pre><code>mkdir ghosts-api\ncd ghosts-api\ncurl https://raw.githubusercontent.com/cmu-sei/GHOSTS/master/src/Ghosts.Api/docker-compose.yml -o docker-compose.yml\ndocker-compose up -d\n</code></pre> </li> <li> <p>Once the command completes, if you open http://localhost:5000/api/home in your browser, you should see the initial API page outlining the version of the install, and a few test machine entries. If this page renders, your API is up, running, and available. If the page does not render, follow the advice in the API troubleshooting section.</p> </li> </ol> <p>You will still need to set up Grafana. Beware that you must often <code>chown g_data</code>, which is the host location for the Graphana container as listed in the docker-compose file. Otherwise, the Grafana container will just continually restart in error due to insufficient permissions (detailed in API troubleshooting).</p>"},{"location":"quickstart/#ghosts-clients","title":"GHOSTS Clients","text":"<p>For any of the clients utilizing the browser, an automation driver is necessary to be included in the same folder as the GHOSTS binary. For Firefox, download the appropriate \ud83e\udd8e Geckodriver for your version of the browser here. For Chrome, download the appropriate  Chromedriver for your version of the browser here.</p> <p>Note there are additional configuration steps for  Outlook email automation.</p> <p>The GHOSTS client should typically be run as a specific user, and not as an administrator or root account.</p>"},{"location":"quickstart/#windows-client","title":"Windows Client","text":"<ol> <li>Your client machine will need to have (at least) the Microsoft DotNet 4.6.1 runtime installed. You do not need the full SDK.</li> <li>Download the latest Windows client.</li> <li>Unzip to your client machine in a directory such as <code>c:\\exercise\\ghosts</code>. You will need to adjust the configuration in <code>config/application.json</code> for your client to talk to the already installed API server from above.</li> </ol>"},{"location":"quickstart/#linux-client","title":"Linux Client","text":"<ol> <li>Your client Linux machine will need to have the latest Microsoft dotnetcore runtime installed (Note that for the GHOSTS client, there are versions for dotnetcoreapp3.1 - this will eventually go away \u2014 and dotnet6.0, which is LTS and should stick around for a while). Again, note that you only need the runtime installed, not the full SDK.</li> <li>Download the latest Linux client zip file. Unzip to a folder such as ~/ghosts for the user that you want GHOSTS to run as.</li> </ol> <p>Note that on Linux machines running the client as root and utilizing web browsing may result in failures due to Gecko/Chromedriver display issues.</p>"},{"location":"advanced/","title":"GHOSTS Advanced Features Overview","text":"<p>The SEI is a research institute, and so we often are thinking about how to use GHOSTS in new ways to drive insight for our customers. Some of this work makes it here, with the caveat that it might be early beta editions or require some amount of engineer hand-holding in its current state. Some call it pre-release, we call it advanced features.</p>"},{"location":"advanced/cyclone/","title":"GHOSTS CYCLONE Overview","text":"Unreleased <p>Coming soon</p>"},{"location":"advanced/enchanter/","title":"GHOSTS ENCHANTER Overview","text":"Unreleased <p>Coming soon</p>"},{"location":"advanced/necromancer/","title":"GHOSTS NECROMANCER Overview","text":"Unreleased <p>Coming soon</p>"},{"location":"animator/","title":"GHOSTS ANIMATOR Overview","text":"GHOSTS ANIMATOR Source Code <p>The GHOSTS ANIMATOR Source Code Repository is hosted on GitHub</p> <p>Animator brings NPCs to life in two ways:</p> <ol> <li> <p>Initial Creation</p> <p>Animator creates the initial NPC profile, including details such as name, address, career, finances, and family members. Based on configuration, it can place users in a multi-level organizational structure, and establish relationships between users.</p> </li> <li> <p>Animation Jobs</p> <p>Via jobs that can be run during training and exercise events, Animator can update the NPC's preferences, beliefs, and relationships. This enables dynamic NPCs that change over time.</p> </li> </ol> <p>At its core, Animator is a realistic user detail generator. Its primary function is to create sufficiently realistic identities and accompanying verbose portfolios of personal information. Each generated user, or NPC (Non-Player Character) as we call them, has numerous categories of details associated with them, and a great deal of metadata that define who they are. Each piece of information is generated using sourced datasets in an attempt to distribute characteristics realistically. We like to say it creates, \"NPCs so real, they sell for a premium on the dark web.\"1</p>"},{"location":"animator/#quick-start","title":"Quick Start","text":"<pre><code>git clone &lt;https://github.com/cmu-sei/GHOSTS-ANIMATOR&gt;\ncd ghosts-animator/src\ndocker build . -t ghosts/animator\ndocker compose up -d\n</code></pre> <p>or if you don't want to build and just run the latest docker-compose file:</p> <pre><code>mkdir ghosts-animator\ncd ghosts-animator\ncurl https://github.com/cmu-sei/GHOSTS-ANIMATOR/blob/master/src/docker-compose.yml -o docker-compose.yml\ndocker compose up -d\n</code></pre> <p>Now browse to http://localhost:5000/</p>"},{"location":"animator/#using-animator-to-create-npcs","title":"Using Animator to Create NPCs","text":"<p>The data generated by Animator can be leveraged in multiple areas, but is particularly applicable in four key areas:</p> <ol> <li> <p>Training Machine Learning Algorithms - Animator creates larges sets of hyper-realistic user data. It can be leveraged to generate data sets that can be used for training machine learning algorithms. This enables the rapid training of anthropology-related ML algorithms that can leverage one or more of the hundred-plus data points generated by Animator.2</p> </li> <li> <p>Honeypot Payloads - NPC details generated by Animator are designed to be as realistic as possible given the available relevant open source information. This makes the user data convincingly real while still being completely fabricated. Therefore, the data is ideal for use in applications like honeypots, where the goal is to trick an attacker into thinking they are compromising an asset with real user data. This data is also perfect for any other application that would benefit from extremely realistic user information.</p> </li> <li> <p>Insider Threat Modeling - Each Animator NPC is given an Insider Threat Profile. This profile determines how likely it is that the NPC is an insider threat by incorporating the CDSE's Insider Threat Potential Indicators. As we continue developing Animator, it will be possible to configure NPCs to be more or less likely to be insider threats based on factors like their finances, criminal history, foreign contacts, and mental health.</p> </li> <li> <p>Social Network and Relationship Modeling - Animator can establish relationships between the NPCs it generates. As we increase the fidelity of inter-NPC relationships, Animator NPCs create larger and more realistic social networks. By leveraging Animator's ability to quickly generate thousands of inter-related NPCs, Animator can easily be used to perform social networking modeling and research.</p> </li> </ol>"},{"location":"animator/#how-creating-npcs-works","title":"How Creating NPCs Works","text":"<ul> <li>Once Animator receives a request to create NPCs, it starts by creating an empty NPC Profile.</li> <li>Animator then iterates through all 100+ data points for the NPC and generates synthetic data to be associated with that NPC.</li> <li>Example data points are name, address, mental health, career, finances, and family members.</li> <li>Data points are either generated at random or are generated using weighted randomization. Weighted randomization involves leveraging verified datasets to influence the distribution of randomly generated data points to match much more closely to reality.</li> <li>Animator will complete this process for as many users as were selected by the request. This information can be exported through the API, or stored in a local database</li> </ul> <p>Animator currently supports storing NPC data in a local Mongo Database. This feature is still being actively improved.</p> <ol> <li> <p>The GHOSTS development team highly recommends Nick Bilton's book American Kingpin for insight into the early days of the dark web.\u00a0\u21a9</p> </li> <li> <p>A key developer from the Animator team went on to a position in the SEI's AI division. AI models need data. You connect the dots.\u00a0\u21a9</p> </li> </ol>"},{"location":"animator/jobs/","title":"Animation Jobs","text":"<p>So, now we have Animator-generated NPCs, and they have profile information and preferences.</p> <p>Animator has a job system that might enables us to push our simulation further:</p> <ul> <li>What motivates an agent?</li> <li>What does an agent know and how did they learn that? How does their knowledge grow over time?</li> <li>What relationships does an agent have off-network? How might this influence what they do on the computer?</li> <li>What does an agent believe? How did they come to that belief?</li> </ul> <p>Jobs operate on a \"per cycle\" or \"step\" basis. For each cycle, the job processes a list of agents, and the actions or determinations programmed for each.</p>"},{"location":"animator/jobs/#decision-making-framework","title":"Decision-Making Framework","text":"<p>We can use any combination of the following to drive agent decision-making:</p>"},{"location":"animator/jobs/#motivation","title":"Motivation","text":"<p>We implement the Reiss Motivational Profile (RMP) - which is a mathematical framework for reasoning about agent comparative motivations - agent A is twice as motivated by X than agent B - that is baselined every few years. </p>"},{"location":"animator/jobs/#relationships","title":"Relationships","text":"<p>Agents build relationships with other agents in the cohort. These get better or worse over time.</p> <p>How this works is that each agent has the potential to interact with n other agents (they can also potentially transfer knowledge as a result). The more an agent knows about a particular subject, maybe the more likely they are to transfer information to another agent.</p>"},{"location":"animator/jobs/#knowledge","title":"Knowledge","text":"<p>Agents build knowledge across an array of subjects that may alter their preferences. Within Animator, there are two main ways to learn:</p> <ul> <li>Independently through study or by utilizing resources such as books or videos</li> <li>Through relationships with others at the coffee counter, through mentorship, or group-based learning (a classroom or team for example). Here NPCs learn via interactions with other agents, and the system tracks what was learned and from whom.</li> </ul>"},{"location":"animator/jobs/#belief","title":"Belief","text":"<p>What an agent believes can directly influence their behavior. Beliefs shape understanding of the world and guide decision-making and problem-solving. Agents come to belief utilizing Bayes Theorem, which is a mathematical framework for reasoning about probability of evidence.</p> <p>So what does this all mean? Here is an example where an agent shares bits of information on social media:</p> <p>Some tweets contain no insight about the agent. Some disclose some bit of information:</p> <ul> <li>Agent knows X fact</li> <li>Agent interacted with Y agent</li> <li>Agent decided to disclose some personal detail Z</li> </ul> <p>Other agents \u2014 and adversaries \u2014 can see and infer from this information!</p>"},{"location":"animator/run/","title":"Running Animator Animations","text":"<p>Animator is a simulation of a population of agents. Animator runs in cycles, and for each cycle, the agents make decisions based on their attributes, preferences, motivations, and behaviors.</p>"},{"location":"animator/run/#setup","title":"Setup","text":"<ul> <li>Get the Animator API up and running as outlined here</li> <li>Edit the <code>appsettings.json</code> file to enable Animations:</li> </ul> <pre><code>\"ApplicationSettings\": {\n\"GhostsApiUrl\": \"http://localhost:52388/\",        // this should be root url of your ghosts API server\n\"Animations\": {\n\"IsEnabled\": false,                             // set this to true to enable animation jobs\n\"SocialGraph\": {\n\"IsEnabled\": false,                           // set this to true to enable the entire module (inc. web gui access)\n\"IsInteracting\": false,                       // set this to true to actually run the interactions\n\"MaximumSteps\": 4000,                         // animator stops when it reaches this many steps \n\"TurnLength\": 900,                            // by default, a step is a cpu cycle, the higher this number, the slower the simulation \n\"ChanceOfKnowledgeTransfer\": 0.3,\n\"Decay\": {\n\"StepsTo\": 10,\n\"ChanceOf\": 0.05\n}\n},\n\"SocialSharing\": {\n\"IsEnabled\": false,                          // set this to true to enable the entire module (inc. web gui access)\n\"IsInteracting\": false,                      // set this to true to actually run the interactions\n\"IsSendingTimelinesToGhostsApi\": false,      // set this to true to actually send the timeline commands to the ghosts API\n\"IsChatGptEnabled\": false,                   // this is still under development, here be dragons\n\"SocializerUrl\": \"http://socializer.com\",    // change this to the root url of your in-game social server\n\"MaximumSteps\": 14000,\n\"TurnLength\": 9000                           // by default, a step is a cpu cycle, the higher this number, the slower the simulation \n},\n\"SocialBelief\": {\n\"IsEnabled\": false,                         // set this to true to enable the entire module (inc. web gui access)\n\"IsInteracting\": false,                     // set this to true to actually run the interactions\n\"MaximumSteps\": 14000,\n\"TurnLength\": 9000\n}\n}\n},\n...\n</code></pre> <p>After you update the appsettings.json file, you will need to restart the Animator API server via:</p> <pre><code>docker restart animator-api\n</code></pre>"},{"location":"content/","title":"GHOSTS Content Servers Overview","text":"<p>GHOSTS content servers are an evolving part of the framework. They exist for several reasons:</p> <ol> <li>On an air-gapped network, where we are simulating some subset of the internet, we want more types of browsable content within that range \u2014 documents, spreadsheets, presentations, pdf files, streamed movies, and the like.</li> <li>We want a broad range of URLs within a site we are representing in the range.</li> <li>We want to simulate a document store, such as SharePoint, OneCloud, or similar, but without the hassle of installing and maintaining those actual systems.</li> </ol> <p>Research by Global WebIndex claims that globally, 59% of the world's population uses social media, and that the average daily use is 2 hours and 29 minutes (July 2022).</p>"},{"location":"content/#air-gaps","title":"Air-gaps","text":"<p>Many ranges are air-gapped, which means they have no access to the wider internet. In these cases, recreating a reasonable facsimile of the internet is key to the training experience. While there are many systems that do this well, we often want to augment the scenario with a wider array of URL traffic, or we want to introduce more of certain kinds of content going across the wire. PANDORA was created to address these concerns. Shortly later, we added a social server as well.</p>"},{"location":"content/#having-to-know-valid-urls","title":"Having to know valid URLs","text":"<p>The other problem is that the internet works by the client having to \u201cknow\u201d the location of some resource via:</p> <ul> <li>Actually knowing the URL</li> <li>Being referred from another page - I might know google.com and search for something, which gives me a reference to another page I was not aware of previously.</li> <li>Inferring the URL from some like resource - If one is poking around and looking for something on a server, a slight change of URL often gives hints that get you to where you wanted to go.</li> <li>Guessing - the proliferation of .com domains means that for something new, it's often fruitful to just try that thing.com and see if it works!</li> </ul> <p>The problem here is that currently, clients must know valid URLs that actually exist out in a simulated greyspace (via TopGen, GreyBox, or otherwise), which limits the array of potential requests and creates range work to maintain. So we created GHOSTS PANDORA, which serves whatever clients ask for - if the request is for a doc file, the server creates a random doc file on the fly \u2014 in memory \u2014 and serves it back to the client. Pandora serves the following content types: </p> <ul> <li>html</li> <li>css</li> <li>js</li> <li>doc|x</li> <li>ppt|x</li> <li>xls|x</li> <li>mp4</li> <li>pdf</li> <li>gif</li> <li>jpg</li> <li>png</li> <li>zip</li> <li>msi</li> <li>iso</li> <li>other binary formats, etc. </li> </ul> <p>Pandora has generic request handlers for each HTTP verb (GET, POST, etc.) and is deployed as a simple docker container. We configure it to handle a particular IP on a multiple-IP-enabled host machine. It works off any URL, but part of the solution involved introducing more randomness in the GHOSTS clients as well. Those clients now support a creative parameter-built URL system that can be configured to look something like this:</p> <pre><code>sharepoint.hello.com/{org}/{report_type}/{uuid}/{file_name}.{file_type}\n</code></pre> <p>These variables are processed at runtime, and produce a final url that might look something like:</p> <pre><code>sharepoint.hello.com/operations/maintenance/80e6af4e-5107-43b5-832f-0d8027efbd76/report.docx\n</code></pre> <p>In addition, Pandora supports \u201cbad\u201d payloads via configuration. Here the server responds to specific configured URLs to deploy planted injects. So clients can download malware in an exercise in a manner that is hard to differentiate based on URLs already seen within the event. The configuration looks like:</p> <pre><code>[payloads]\n1=/bad/payload/url/,some_bad.zip,application/zip\n</code></pre> <p>Where id=url,payload file, MIME response type.</p>"},{"location":"content/pandora/","title":"GHOSTS PANDORA SERVER Overview","text":"Pandora is part of GHOSTS <p>Pandora is within the GHOSTS Source Code Repository hosted on GitHub.</p> <p>GHOSTS PANDORA is a web server that responds to a myriad of request types with randomized content generated in real-time. Used in conjunction with GHOSTS NPCs, the two can provide for agents that are periodically downloading content other than simple HTML and associated image, CSS, and js files.</p> <p></p>"},{"location":"content/pandora/#running-this-server","title":"Running this server","text":""},{"location":"content/pandora/#as-a-docker-container","title":"As a Docker Container","text":"<p>Docker is the preferred way to run Pandora - mostly because this is how we run and test it before version releases.</p> <ol> <li>Review the repository docker-compose.yml file</li> <li>Run the following in your terminal </li> </ol> <pre><code>mkdir ghosts-pandora\ncd ghosts-pandora\ncurl https://raw.githubusercontent.com/cmu-sei/GHOSTS/master/src/ghosts.pandora/docker-compose.yml -o docker-compose.yml\ndocker-compose up -d\n</code></pre>"},{"location":"content/pandora/#bare-metal","title":"Bare metal","text":"<p>This assumes the host server is a common Linux distribution. For images to render correctly, PIL or the more recent Pillow library is necessary. See here for more information on Pillow installation and configuration.</p> <ol> <li>Using a Python 3 distribution &gt;= 3.6.2</li> <li>In the terminal run: <code>pip install -r requirements.txt</code></li> <li>Then run <code>python app.py</code></li> </ol>"},{"location":"content/pandora/#capabilities","title":"Capabilities","text":""},{"location":"content/pandora/#handling-requests-by-directory","title":"Handling requests by directory","text":"<ul> <li>/api - All requests beginning with <code>/api</code> automatically respond with json. This includes:<ul> <li><code>/api/users</code></li> <li><code>/api/user/a320f971-b3d9-4b79-bb8d-b41d02572942</code></li> <li><code>/api/reports/personnel</code></li> </ul> </li> <li>/csv - All requests beginning with <code>/csv</code> automatically respond with csv. Like the above, this includes urls such as:<ul> <li><code>/csv/users</code></li> <li><code>/csv/user/winx.jalton</code></li> <li><code>/csv/reports/HR/payroll</code></li> </ul> </li> <li>/i, /img, /images - All requests beginning with these directories automatically respond with a random image of type [gif, jpg, png]. Examples:<ul> <li><code>/i/v1/a9f6e2b7-636c-4821-acf4-90220f091351/f8f8b1f0-9aa5-4fc7-8880-379e3192748e/small</code></li> <li><code>/images/products/184f3515-f49b-4e07-8c8b-7f978666df0e/view</code></li> <li><code>/img/432.png</code></li> </ul> </li> <li>/pdf - All requests respond with a random pdf document. Examples:<ul> <li><code>/pdf/operations/SOP_Vault/a7f48bd5-84cb-43a1-8d3d-cd2c732ddff6</code></li> <li><code>/pdf/products</code></li> </ul> </li> <li>/docs - All requests respond with a random word document</li> <li>/slides - All requests respond with a random powerpoint document</li> <li>/sheets - All requests respond with a random excel document</li> </ul>"},{"location":"content/pandora/#handling-requests-by-type","title":"Handling requests by type","text":"<p>For requests indicating a specific file type, there are several specific handlers built to respond with that particular kind of file, such as:</p> <ul> <li>.csv</li> <li>Image requests [.gif, .ico, .jpg, .jpeg, .png]</li> <li>.json</li> <li>Office document requests</li> <li>.doc, .docx</li> <li>.ppt, .pptx</li> <li>.xls, .xlsx</li> <li>.pdf</li> </ul> <p>So that a URL such as <code>/users/58361185-c9f2-460f-ac45-cb845ba88574/profile.pdf</code> would return a pdf document typically rendered right in the browser.</p> <p>All unhandled request types, urls without a specific file indicator, or requests made outside specifically handled directories (from the preceding section) are returned as html, including:</p> <ul> <li><code>/docs/by_department/operations/users</code></li> <li><code>/blog/d/2022/12/4/blog_title-text</code></li> <li><code>/hello/index.html</code></li> </ul>"},{"location":"content/pandora/#hiding-malicious-payloads-for-red-teaming","title":"Hiding malicious payloads for red-teaming","text":"<p>Pandora also can hide payloads in a particular request for things like red-teaming and such. This is done in the configuration file, and looks like this:</p> <pre><code>[payloads]\n1=/1/,a.zip,application/zip\n2=/2/users,b.zip,application/zip\n3=/3/some/report/url,c.zip,application/zip\n</code></pre> <p>Each record must be an incrementing integer with no duplication. The values are:</p> <ul> <li>The URL that this payload responds to</li> <li>The local file (stored in <code>./payloads/</code>) to be returned</li> <li>The MIME type of the response</li> </ul> <p>So for 1 in the example above, requests to /1/ return the a.zip file as an application/zip file.</p>"},{"location":"content/social/","title":"GHOSTS PANDORA SOCIAL Overview","text":"PANDORA SOCIAL is still very early beta <p>Here be dragons</p> <p>The place where GHOSTS agents come to share their thoughts and information.</p> <p>In the spirit of the original PANDORA, this server also responds to a very broad array of URLs but enables clients to POST/PUT/DELETE to it as well, for example:</p> Request Response <code>POST</code> /images  responds with a url to the saved image file <code>POST</code> /  responds with a randomly-generated streamed video <code>POST</code> /users/michelle_smith/af2d00aa-4a89-4af3-baff-1746b556e7a1/  responds with a reply to the original user's social post"},{"location":"core/api/","title":"GHOSTS Core API Overview","text":"GHOSTS Source Code <p>The GHOSTS Source Code Repository is hosted on GitHub.</p> <p>The GHOSTS API enables the control and orchestration of non-player characters (NPCs) within a deployment. It supports logging, reporting, and managing individual, groups of, or entire deployments of client installs.</p>"},{"location":"core/api/#installation","title":"Installation","text":"<ol> <li>Install \ud83d\udc33 Docker </li> <li>Install Docker Compose </li> <li>Run the following commands - we'll use this docker-compose.yml file</li> </ol> <pre><code>mkdir ghosts\ncd ghosts\ncurl https://raw.githubusercontent.com/cmu-sei/GHOSTS/master/src/Ghosts.Api/docker-compose.yml -o docker-compose.yml\ndocker-compose up -d\n</code></pre> <p>The required containers will be downloaded and configured automatically.</p> <p>Once the last command completes, if you open http://localhost:5000/api/home in your browser, you should see the initial API page outlining the version of the install, and a few test machine entries. If this page renders, your API is up, running, and available.</p> <p>You will still need to set up Grafana. Beware that you must often <code>chown</code> the host location of the container as listed in the docker-compose file or the container will just continually restart in error due to insufficient permissions.</p>"},{"location":"core/api/#configuring-the-api","title":"Configuring the API","text":"<p>The API generally has good defaults to get you up and running quickly, but there are some considerations in the <code>appconfig.json</code> file:</p> <pre><code>    \"ClientSettings\": {\n\"OfflineAfterMinutes\": 30, ...\n\"MatchMachinesBy\": null,\n</code></pre> <p>Can be fqdn|host|resolvedhost|null - null tells the API to match incoming requests with machine records by the machine name. For installations where multiple domains are reporting into the same API, you probably want to use FQDN in order to avoid machines being duplicated.</p> <pre><code>\"QueueSyncDelayInSeconds\": 10,\n\"NotificationsQueueSyncDelayInSeconds\": 10,\n</code></pre> <p>This is how often the synch job runs. Incoming machine requests are not real-time in order to best bundle like records together.</p>"},{"location":"core/api/#configuring-grafana","title":"Configuring Grafana","text":"<ul> <li>Grafana will be running (if containerized) on port 3000, and we can access it via the same URL we use for the API.</li> <li>The default login is admin/admin.</li> <li>The first step is to set up a datasource named \"ghosts\" to the ghosts Postgres database.</li> <li>Now import your choice of the grafana json files in this repository. It creates the default GHOSTS dashboard.</li> </ul>"},{"location":"core/api/#webhooks","title":"Webhooks","text":"<p>The GHOSTS API provides webhook callbacks based on the configuration on the endpoint: <code>/api/webhooks</code>. The payload for creating a webhook is in the format:</p> <pre><code>{\n\"status\": 0,\n\"description\": \"some description\",\n\"postbackUrl\": \"http://localhost/endpoint:port\",\n\"postbackMethod\": 0, (0 == get, 1 == post)\n\"postbackFormat\": \"see below\"\n}\n</code></pre> <p>Payloads can be any format \u2014 here is a sample:</p> <pre><code>{\n'machine':'[machinename]',\n'created':'[datetime.utcnow]',\n'type':'[messagetype]',\n'payload':'[messagepayload]'\n}\n</code></pre> <p>On send, the payload will be converted into the correct JSON format:</p> <pre><code>{\n\"machine\":\"some_guid\",\n\"created\":\"some_datetime\",\n\"type\":\"some_message\",\n\"payload\":\"some_payload\"\n}\n</code></pre> <p>If the postback method is POST, the payload will be sent as the message body. If the postback method is GET, the payload will be sent as part of the querystring value ?message=<code>payload</code>.</p> <p>The following events are reported via webhooks:</p> <ol> <li>Timeline delivered (with the timeline that was delivered as payload) to a machine via API (original API posting of timeline only holds timeline in wait - the client still must check-in in order for that timeline to be delivered)</li> <li>Machine requested updates (\"checked in\") from API</li> <li>Machine posted results to API</li> </ol>"},{"location":"core/api/#troubleshooting","title":"Troubleshooting","text":"<p>Is the API up and running?</p> <ul> <li>Go to <code>/api/home</code> in the browser, it should return the current API version and the number of machines and groups under management. If it says relationship not found, restart the API application and it should create the database automatically.</li> <li>Run <code>docker ps --all</code> and see that all containers are running normally. If one or more is not running, look at the logs for that machine via <code>docker logs [machine name]</code>.</li> </ul> <p>The ClientId, ClientResults, and other Client* endpoints are failing.</p> <p>The Client* endpoints are for the Clients to use only. There are specific header values set by the client in the request that is used to authenticate the request. If you are not using the client, you will not have these headers set, and these endpoints will fail.</p>"},{"location":"core/client/","title":"GHOSTS Core Client Overview","text":"GHOSTS Source Code <p>The GHOSTS Source Code Repository is hosted on GitHub.</p> <p>The GHOSTS client simulates what anyone might do at a computer given their particular role or membership within some team. It creates documents, browses websites, downloads files, and uses all sorts of popular applications on many versions of Windows and Linux machines. Whether you're a friendly administrator or a powerful cyber adversary, GHOSTS can replicate your expected behavior.</p> <p></p> <p>GHOSTS has many use cases in cyber training and exercises, most notably for bringing non-player characters (NPCs) to life, but it can also be used for other purposes where realistic activity on a computer or network is needed - testing or generating datasets, for example.</p> Do I need the API? <p>Although clients are fully functional without the API server, the latter enables logging, reports, and remote administration capabilities. Without the API, changes to clients must be managed in some other manner.</p> <p>The client's configuration and command system are file-based, so if you do not wish to use the API, you can manage these through some other tool, such as Ansible or similar. All of these files are under the client's install location.</p> Run as the NPC you're representing <p>The GHOSTS client should typically be run as a user, and not as administrator or root - training or exercising teams will notice this immediately.</p>"},{"location":"core/client/#the-windows-client","title":"The Windows Client","text":"<p>GHOSTS on Windows (Win10 and Win7 currently supported) is a .NET Console application that performs user activity on client workstations - web browsing, working with office documents, using the command prompt or PowerShell, etc. Our team typically installs the client in an out-of-game directory (<code>c:\\exercise\\ghosts\\</code>), where no event or injects will originate. It is recommended you verify one working client before deploying to multiple machines. You will need the base URL from the API installation for the client to communicate home.</p>"},{"location":"core/client/#windows-installation","title":"Windows Installation","text":"<ul> <li> <p>Your client Windows machine will need to have (at least) the Microsoft DotNet 4.6.1 runtime installed . Again, note that you only need the runtime, not the full SDK. We continue to use 4.6.1 on Windows to maintain backward compatibility.</p> </li> <li> <p>Download the appropriate latest client</p> </li> </ul> <p>Unzip to your client machine in a directory such as <code>c:\\exercise\\ghosts</code>. You will need to adjust the configuration in <code>config/application.json</code> for your client to talk to your an installed instance of the GHOSTS API server.</p> Additional configuration required for web browsing <p>For any client utilizing the Firefox or Chrome web browser, an automation driver is necessary to be included in the same folder as the GHOSTS binary. For Firefox, download the appropriate \ud83e\udd8e\u00a0 Geckodriver for your version of the browser here . For Chrome, download the appropriate Chromedriver for your version of the browser here .</p> Additional configuration required for email <p>Using the Windows client email functions requires the use of Redemption  which provides robust Outlook automation. The full Redemption library should be found in <code>/lib</code>.</p>"},{"location":"core/client/#linux-client","title":"Linux Client","text":"<p>Your client Linux machine will need to have the latest Microsoft dotnetcore runtime  installed (Note that for the GHOSTS client, there are versions for dotnetcoreapp3.1 - this will eventually go away \u2014 and dotnet6.0, which is long term support (LTS) and will stick around for a while). Again, note that you only need the runtime installed, not the full SDK.</p>"},{"location":"core/client/#linux-installation","title":"Linux Installation","text":"<ul> <li>Download the latest Linux client</li> </ul> <p>Unzip to a folder such as <code>~/ghosts</code> for the user that you want GHOSTS to run as.</p> <p>Note that on Linux machines running the client as root and utilizing web browsing may result in failures due to Gecko/Chromedriver display issues.</p>"},{"location":"core/client/#client-directory-structure","title":"Client Directory Structure","text":"Do not copy the instance folder <p>You should never copy the <code>instance</code> folder from one machine to another.</p> Folder Description <code>config/</code> configuration files are stored here. <code>instance/</code> generated files and information relative to this particular installed instance of ghosts is stored here. This folder should never be copied from one machine to another <code>lib/</code> third-party libraries used by ghosts are stored here <code>logs/</code> output logs for the installed instance (logs/app.log), and logs that are transferred to the server (<code>logs/clientupdates.log</code>)"},{"location":"core/client/#configuration-quick-start","title":"Configuration Quick Start","text":"<p>After unzipping the GHOSTS client, we can simply double-click it to run. Note that the console window likely printed a few messages, but then disappeared. This is normal, in production mode GHOSTS hides itself. We can see it in the Windows Task Manager, however, and we can kill the process from there. We can also run the included <code>kill-ghosts.bat</code> file that closes the application and any applications it might control.</p> <p>Beyond this initial step of verifying that the client will run, there are two files that we might need to adjust to fit many deployments:</p>"},{"location":"core/client/#applicationjson","title":"application.json","text":"<p>In this file, often all we need to change are the URLs for the API, IdUrl, ClientResultsUrl, ClientUpdatesUrl, and the like. Change the hostname to your installed API location, and GHOSTS should check in as expected.</p> <pre><code>{\n\"IdEnabled\": true,                                                      //enabled in order to command and control from api (C2) server\n\"IdUrl\": \"http://yourapiurl.com/api/clientid\",                          //url for API endpoint to get clientid\n\"ClientResultsEnabled\": true,                                           //enabled to report results to C2\n\"ClientResultsUrl\": \"http://yourapiurl.com/api/clientresults\",          //url for API endpoint to report results\n\"ClientResultsCycleSleep\": 90,                                          //report results every x ms\n\"ClientUpdatesEnabled\": true,                                           //enabled to get updates from C2\n\"ClientUpdatesUrl\": \"http://yourapiurl.com/api/clientupdates\",          //url for API endpoint to get updates\n\"ClientUpdatesCycleSleep\": 90,                                          //check for updates every x ms\n\"Survey\": {                                                             //survey is a local report of processes running, etc.\n\"IsEnabled\": true,                                                  //on/off\n\"Frequency\": \"once\",                                                //how often to survey\n\"MaxAgeInHours\": 168,                                               //how long to wait until new survey\n\"OutputFormat\": \"indent\"                                            //compact/fancy(indent)\n},\n\"HealthIsEnabled\": true,                                                //enable local health checks\n\"HandlersIsEnabled\": true,                                              //enable local timeline activity\n\"ChromeExtensions\": \"\",                                                 //comma separated local extensions (used for injects in the past)\n\"FirefoxInstallLocation\": \"\",                                           //geckodriver needs this for non-standard installs (is pesky)\n\"FirefoxMajorVersionMinimum\": 48,                                       //geckodriver is picky about versions\n\"OfficeDocsMaxAgeInHours\": 6,                                           //cleanup kills docs in the documents folder older than this setting\n}\n</code></pre>"},{"location":"core/client/#timelinejson","title":"timeline.json","text":"<p>The other file we may want to adjust is the default timeline. This is what the agent does all day, including browsing the internet, creating documents, and similar. The defaults hopefully give you a good idea of what is possible, and of course, the array of configurations here is endless - be creative!</p> <p>The primary item is the HandlerType. This tells GHOSTS to run a command (Command), use Firefox to browse an array of websites (BrowserFirefox), create Excel documents (Excel)  and so on. Some of the other items related to a handler's configuration are:</p> <ul> <li>Initial: The initial command for a handler to execute. For a web browser, you might enter either a URL or \"about:blank\".</li> <li>UtcTimeOn | UtcTimeOff: \"00:00:00\": \"24:00:00\" to not shut off. Otherwise, enter an on and an off time to simulate things such as office hours of 9-5, etc. There are 30 minutes of jitter plus or minus from the time entered.</li> <li>Loop: Set this to true to continue to execute this same command on a loop, or false to execute something just one time.</li> </ul> <pre><code>{\n\"HandlerType\": \"Command\",\n\"Initial\": \"\",\n\"UtcTimeOn\": \"00:00:00\",\n\"UtcTimeOff\": \"24:00:00\",\n\"Loop\": \"True\",\n\"TimeLineEvents\": [\n{\n\"Command\": \"NETSTAT\",    \"CommandArgs\": [],\n\"DelayAfter\": 900000,\n\"DelayBefore\": 0\n}\n]\n}\n</code></pre> <p>To access a network share file, the command might be: net use X:\\SERVER\\Share</p> <p>To RDP to another machine: mstsc.exe {ConnectionFile | /v:ServerName[:Port]} [/console] [/f] [/w:Width/h:Height]</p> <p><code>/v</code> - specifies the remote computer and port (optional) you wish to connect to <code>/console</code> \u2013 connects to the console of a Windows Server 2003 based system <code>/f</code> \u2013 starts the remote desktop connection in full screen mode <code>/w &amp; /h</code> \u2013 specifies the width and height of the remote desktop connection</p> <p>Actions can also be created for standard copy/move/deletion of files via their respective commands.</p> <p>Chrome</p> <p>We have to pass the browser window an initial value. If we don't want it to go anywhere at start, we could pass about:blank, otherwise we'd pass a url. These can be http or https.</p> <pre><code>{\n\"HandlerType\": \"BrowserChrome\",\n\"Initial\": \"http://google.com\",\n\"UtcTimeOn\": \"00:00:00\",\n\"UtcTimeOff\": \"24:00:00\",\n\"Loop\": \"True\",\n\"TimeLineEvents\": [\n{\n\"Command\": \"random\",\n\"CommandArgs\": [\n\"http://google.com\",\n\"http://facebook.com\",\n],\n\"DelayAfter\": 1000,\n\"DelayBefore\": 0\n}\n]\n}\n</code></pre> <p>Excel, PowerPoint, Word</p> <pre><code>{\n\"HandlerType\": \"Word\",\n\"Initial\": \"\",\n\"UtcTimeOn\": \"00:00:00\",\n\"UtcTimeOff\": \"24:00:00\",\n\"Loop\": \"True\",\n\"TimeLineEvents\": [\n{\n\"Command\": \"create\",\n\"CommandArgs\": [ \"%homedrive%%homepath%\\\\Documents\" ],\n\"DelayAfter\": 900000,\n\"DelayBefore\": 0\n}\n]\n}\n</code></pre>"},{"location":"core/client/#trackables","title":"Trackables","text":"<p>For specific Timeline Events where the outcome is needed to be tracked, like for example, a client machine spawned inject, use a Trackable (via TrackableId in the following example):</p> <pre><code>{\n\"TimeLineHandlers\": [\n{\n\"HandlerType\": \"BrowserChrome\",\n\"Initial\": \"about:blank\",\n\"UtcTimeOn\": \"00:00:00\",\n\"UtcTimeOff\": \"24:00:00\",\n\"Loop\": false,\n\"TimeLineEvents\": [\n{\n\"Command\": \"browse\",\n\"CommandArgs\": [ \"https://dl.dafont.com/dl/?f=italian_breakfast\" ],\n\"DelayAfter\": 0,\n\"DelayBefore\": 0\n},\n{\n\"Command\": \"download\",\n\"CommandArgs\": [ \"//a[contains(@class, 'dl')]\" ],\n\"TrackableId\": \"&lt;guid id from trackables table/&gt;\",\n\"DelayAfter\": 0,\n\"DelayBefore\": 0\n}\n]\n},\n{\n\"HandlerType\": \"Command\",\n\"Initial\": \"\",\n\"UtcTimeOn\": \"00:00:00\",\n\"UtcTimeOff\": \"24:00:00\",\n\"Loop\": false,\n\"TimeLineEvents\": [\n{\n\"Command\": \"cd %homedrive%%homepath%\\\\Downloads\",\n\"CommandArgs\": [\n\"powershell expand-archive -Path italian_breakfast.zip -destinationpath x\",\n\"cd x\",\n\"dir\"\n],\n\"TrackableId\": \"&lt;guid id from trackables table/&gt;\",\n\"DelayAfter\": 10,\n\"DelayBefore\": 10000\n}\n]\n}\n]\n}\n</code></pre>"},{"location":"core/client/#troubleshooting","title":"Troubleshooting","text":"<p>Clients aren't running (immediately exiting, throwing copious exceptions, or similar)</p> <ul> <li>Is the dotnet framework runtime 4.x installed on the machine?</li> <li>If GPO is doing white-listing of what apps can run, is <code>ghosts.exe</code> white-listed?</li> <li>Will the client run by simply double-clicking on the exe?</li> <li>Does it report anything to the windows application event logs?</li> <li>What's in <code>logs/app.log</code>?</li> <li>Is the ghosts executable set to execute automatically when the machine restarts?</li> </ul> <p>Clients aren't reporting their activity to the API</p> <ul> <li>Is the client running correctly? (if not, see above)</li> <li>Is there entries in the logs/clientupdates.log?</li> <li>If there are, is the file too large? (Try removing it, ghosts might be hung trying to process a lot of log data)</li> <li>If the folder <code>instance</code> created? Does the file <code>instance/id.json</code> exist? (If it does and has an ID within, then ghosts has reported home to the api at least once)</li> <li>The file <code>logs/app.log</code> indicating any fatal issues? (Logging can be ratcheted up and down via nlog configuration)</li> </ul> <p>Can I update what clients are doing?</p> <ul> <li>Clients operate off their <code>config/timeline.json</code> file and this can be updated via Powershell, Ansible, or other means - it's just a file.</li> <li>Clients can also do just-in-time activities via the <code>instance/timeline/in</code> folder. Anything placed here will be picked up, executed, and moved to the corresponding out folder once complete. This does not affect any activity currently controlled with the default timeline file.</li> </ul> <p>Can I reset a client on a box?</p> <ul> <li>Yes, launching a new instance of Ghosts kills the previous one and all associated tasks from the timeline (any instances of Word, PowerShell, etc.). Only one instance of Ghosts will be running on a client box at any time. We can also run the .bat script <code>kill-ghosts.bat</code> included in the distribution to clean everything up.</li> </ul> <p>What is the easiest way to determine the running version of the client?</p> <ul> <li>run the version flag: <code>ghosts.exe --version</code></li> </ul>"},{"location":"core/handlers/","title":"Basic Handler Configuration","text":"<p>The following is the format for a basic timeline handler:</p> <pre><code>\"TimeLineHandlers\": [\n{\n\"HandlerType\": \"Watcher\",\n\"UtcTimeOn\": \"00:00:00\",\n\"UtcTimeOff\": \"24:00:00\",\n\"Loop\": true,\n\"TimeLineEvents\": [\n{\n\"Command\": \"folder\",\n\"CommandArgs\": [ \"path:%HOMEDRIVE%%HOMEPATH%\\\\Downloads\", \"size:2000\", \"deletionApproach:oldest\" ],\n\"DelayAfter\": 0,\n\"DelayBefore\": 0\n}\n]\n}\n]\n</code></pre> <p>Some of the key-value pairs are self-explanatory, but let's review a few important ones:</p> Key Value <code>HandlerType</code> The application or major function we want to control. This could be FireFox, the Cmd terminal, or Word. <code>UtcTimeOn</code> The time the handler will begin to run. To simulate an agent coming into the office at 0900, we set this to your time zone's UTC value. <code>UtcTimeOff</code> The time the handler will stop. To simulate an agent leaving the office at 1700, we set this to your time zone's UTC value. <code>Loop</code> true or false - a handler could be repeated or just run one-time."},{"location":"core/api/timelines/","title":"Managing Timelines","text":"<p>One of the primary capabilities of the API is to manage multiple client timelines. Timelines are the mechanism for clients to perform actions on behalf of a user. For example, a client might execute a timeline to browse a website, create a document, or other Handler activities.</p> <p>Clients are configured to check in periodically with the API to report their current state and to check if any updates are available. We can have the API hold an update for the next time a client, group of clients, or all clients check in. That update will then be processed by the client and the client will report back to the API that the update has been processed. This allows the API to manage the state of the client and to ensure that the client is always up to date. So the process is:</p> <ol> <li>We configure an update for a client or group of clients in the API.</li> <li>Clients check in and are told that an update is available.</li> <li>The client processes the update and reports back to the API that the update has been processed.</li> </ol>"},{"location":"core/api/timelines/#configuring-a-timeline-for-a-client","title":"Configuring a Timeline for a Client","text":"<p>Client timelines are updated via POST to /api/timelines in the following format:</p> <pre><code>{\n\"machineId\": \"3fa85f64-5717-4562-b3fc-2c963f66afaf\",\n\"type\": 0,\n\"activeUtc\": \"2023-03-08T16:38:04.002Z\",\n\"status\": 0,\n\"update\": {\n\"status\": 0,\n\"timeLineHandlers\": [\n{\n\"handlerType\": 0,\n\"initial\": \"string\",\n\"utcTimeOn\": {\n\"ticks\": 0\n},\n\"utcTimeOff\": {\n\"ticks\": 0\n},\n\"handlerArgs\": {\n\"additionalProp1\": \"string\",\n\"additionalProp2\": \"string\",\n\"additionalProp3\": \"string\"\n},\n\"loop\": true,\n\"timeLineEvents\": [\n{\n\"trackableId\": \"string\",\n\"command\": \"string\",\n\"commandArgs\": [\n\"string\"\n],\n\"delayAfter\": 0,\n\"delayBefore\": 0\n}\n]\n}\n]\n}\n}\n</code></pre> <p>The key values to consider here are: The machine ID that you want to update, the other key value is the <code>type</code> of timeline. The type is an integer value that represents the type of update. The following are the types of updates that are currently supported:</p> <ul> <li>Timeline = 0            // this </li> <li>Health = 1</li> <li>TimelinePartial = 10    // this the agent is currently doing off its default timeline</li> <li>RequestForTimeline = 20</li> </ul> ID Type Description 0 Timeline Replaces the client's default timeline stored within ./config/timeline.json 1 Health This updates a client's health instructions 10 TimelinePartial Does not replace the default timeline, rather this timeline is executed immediately on separate threads from whatever 20 RequestForTimeline Use this to instruct the client to send its current default timeline up to the API <p>The remainder of the settings are for the timeline - basically what we are doing here is sending a client a new timeline, with the above values to indicate, which machine and what to change in the <code>update</code> node.</p>"},{"location":"core/handlers/browser/","title":"Web Browser (Firefox|Chrome) Configuration","text":"<p>A sample timeline for each browser is available in a code repository directory of the same name.</p>"},{"location":"core/handlers/browser/#timeline-url-variables","title":"Timeline URL Variables","text":"<p>An example of a URL using variables is: </p> <pre><code>http://craigslist.org/{org}/{group}/{uuid}/{verb}/{type}/{n}?{c}={now}\n</code></pre> <p>All variables are in the format <code>{variable}</code>. There are several standard variables:</p> <ul> <li><code>{now}</code> = short datetime (mm/dd/yyyy format)</li> <li><code>{uuid}</code> = uuid</li> <li><code>{c}</code> = a single character from a-z and A-Z</li> <li><code>{n}</code> = number between 1 and 1000</li> </ul> <p>We can also configure additional variables by adding the following to a browser handler in a timeline:</p> <pre><code>\"url-replace\": [\n{\"verb\": [\"order\", \"enable\", \"engage\"]},\n{\"group\": [\"operations\", \"logistics\", \"medical\"]},\n{\"org\": [\"army\", \"command\", \"brigade\", \"battalion\"]},\n{\"type\": [\"document\", \"doc\", \"files\", \"vault\", \"filevault\"]}\n]\n</code></pre> <p>Therefore:</p> <pre><code>https://www.cmu.edu/{org}/{group}/{verb}/{type}/{uuid}/version_{n}?{c}={now}\n</code></pre> <p>might be rendered as:</p> <pre><code>https://www.cmu.edu/command/operations/order/doc/bcc396b5-47d0-4665-93c8-0a314cec13e1/version_55?d=6/21/2022\n</code></pre>"},{"location":"core/handlers/excel/","title":"Excel Configuration","text":""},{"location":"core/handlers/powerpoint/","title":"PowerPoint Configuration","text":""},{"location":"core/handlers/word/","title":"Word Configuration","text":""},{"location":"spectre/","title":"GHOSTS SPECTRE Overview","text":"GHOSTS SPECTRE Source Code <p>The GHOSTS SPECTRE Source Code Repository is hosted on GitHub</p> <p>SPECTRE is our attempt to reduce that agent browsing patterns appear as \"computer random\".1 This module modifies user web browser timelines so that they more closely match that agent's preferences over time. We expect this simple model of ML to be used for other types of agent activity in the future.</p> <p>Agent browsing patterns are no longer random and match different types of users on a network. These patterns improve over time.</p> <p>Also, this simple model of ML can now be used for other types of agent activity. This makes for an exciting future on the GHOSTS platform.</p> <p>Using Machine Learning to Increase NPC Fidelity with Dynamic Preferences Used in Forward-Looking Decisions</p> <p>As GHOSTS agents make more informed, and hopefully, more complex decisions, there is a need for each agent to have a system of preferences existing at the time the agent is created, and for an ability to update those preferences over time as the agent continues to make decisions and measure the outcome of those decisions afterwards.</p> <p>SPECTRE provides GHOSTS enables agents to make preferenced decisions and to use the outcome of those decisions to learn and evaluate future choices more intelligently.</p>"},{"location":"spectre/#how-it-works","title":"How it works","text":"<p>SPECTRE currently has two components:</p>"},{"location":"spectre/#preference-engine","title":"Preference Engine","text":"<ol> <li>An administrator creates the types of personas they wish to have GHOSTS agents represent</li> <li>GHOSTS agents report in their browser history to the GHOSTS C2 API</li> <li>If the agent has no persona, SPECTRE assigns one at random</li> <li>The persona assignment randomly creates different preferences for the agent based on persona settings (not unlike character creation in D&amp;D)</li> <li>Preferences are a preference and its numeric value (-100 to 100) which roughly represents how much an agent likes or dislikes something</li> <li>Preferences can be any <code>key:value</code> pair, such as:          \"sports\":50          \"kali\":35          \"127.0.0.1\":77</li> <li>Preferences of 0 mean that the agent is indifferent (or has no preference)</li> <li>All preference history is stored so that in the (near) future we can track an agent's preferences over time</li> <li>It is assumed that high negative preferences would have agents avoiding those values (e.g. for \"onions\":-100 one would assume an agent is avoiding eating onions at all costs.)</li> </ol>"},{"location":"spectre/#machine-learning","title":"Machine Learning","text":"<p>The incoming GHOSTS agent browsing activity can be attenuated to individual agent preferences after they are assigned some number of preferences based on default persona profiles. SPECTRE will aggregate this information periodically and perform model training and testing against that browsing activity, and recommend new browsing patterns for that agent to execute. This creates a new activity timeline for the agent. This cycle is referred to as a \"Test\". After any given test, that information would be used to inform the next round of ML testing to be done.</p>"},{"location":"spectre/#installation","title":"Installation","text":"<p>SPECTRE installs alongside an existing GHOSTS installation as a separate docker container. With a few configuration changes, you should be up and running in minimal time.</p> <p>There are only two configuration settings, both contained within <code>appsettings.json</code>:</p> <pre><code>\"DefaultConnection\": \"Host=localhost;Port=5432;Database=preferences;User Id=ghosts;Password=scotty@1;Pooling=true;Command Timeout=9900\",\n\"GhostsApiUrl\": \"http://localhost:5000\"\n</code></pre> <p>The first setting is for your connection to a necessary Postgres database, which SPECTRE will use for its operations. It is fine to host this on the same machine or container that you might be using for GHOSTS itself. In this case, either use the same user as GHOSTS or create a new user for SPECTRE.</p> <p>The second setting is for SPECTRE to access the GHOSTS API endpoints. This is used to get information about machines and to update their timelines, based on SPECTRE findings and executions.</p>"},{"location":"spectre/#quick-start","title":"Quick Start","text":"<p>Spectre is rather like an add-on -- it sits alongside the core API and uses that system to get its initial agent information, process their timelines, and then post updated timelines back to the API for dissemination to the clients.</p> <ul> <li>There is one setting in the spectre <code>appsettings.json</code> file that may need updating based on the install - it is how Spectre will connect to the GHOSTS Core API: <code>\"GhostsApiUrl\": \"http://host.docker.internal:52388\"</code> \u2014\u00a0update this to your core API host and port.</li> <li>Now go to Spectre's host:port/swagger to bring up the API.</li> <li><code>GET /Agents</code> will show you what you have under SPECTRE control - at the start, it is likely no agents. We need to sync with core GHOSTS Core API to get its agents into SPECTRE.</li> <li>So, we need to run <code>POST /Agents/sync</code> once to pull the agents in the core API over to SPECTRE.</li> <li>Now Spectre's <code>GET /Agents</code> will show you the same agents from ghosts Core API.</li> <li>You can now run a browse recommendations job.</li> </ul> <ol> <li> <p>This work is detailed in the technical report Using Machine Learning to Increase NPC Fidelity. Some of the team also discussed this project in an SEI podcast episode, entitled ML-Driven Decision-Making in Realistic Cyber Exercises.\u00a0\u21a9</p> </li> </ol>"}]}